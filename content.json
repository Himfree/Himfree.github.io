{"meta":{"title":"KeTing","subtitle":"","description":"","author":"Liu Keting","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-10-02T02:36:40.000Z","updated":"2022-10-02T02:37:43.707Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-02T02:38:07.000Z","updated":"2022-10-02T02:38:45.960Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"关于作者","date":"2022-10-02T02:41:38.000Z","updated":"2022-10-02T02:42:24.595Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-02T02:35:29.000Z","updated":"2022-10-02T02:37:41.406Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-02T07:05:22.352Z","updated":"2021-10-10T03:33:23.428Z","comments":true,"path":"categories/C++方向编程题答案.html","permalink":"http://example.com/categories/C++%E6%96%B9%E5%90%91%E7%BC%96%E7%A8%8B%E9%A2%98%E7%AD%94%E6%A1%88.html","excerpt":"","text":"C++方向编程题答案第一周day2 题目ID：100448 排序子序列链接：https://www.nowcoder.com/questionTerminal/2d3f6ddd82da445d804c95db22dcc471?orderByHotValue=1&amp;page=1&amp;onlyReference=false 【题目解析】：本题要求解的是排序子序列，排序子序列为非递增或者非递减，很多同学在这个非递增、非递减问题上很纠结，注意：非递减就是a[i]&lt;&#x3D;a[i+1]，递减就是a[i]&gt;a[i+1]，非递增就是a[i]&gt;&#x3D;a[i+1]，递增就是a[i]&lt;a[i+1]。其实这个不理解网上搜一下就理解了。 【解题思路】：解题思路： 本题依次比较整个数组 a[i+1]&gt;a[i] ，则进入非递减序列判断，直到遍历到下一个值不大于等于为止count++，然后进行下一位置的判断 a[i+1]&lt;a[i]，则进入非递增序列判断，直到遍历到下一个值不小于等于为止count++，然后进行下一位置的判断 a[i+1] &#x3D;&#x3D; a[i]不进行操作，++i进行下一位置遍历，因为相等既可以属于非递增序列，也可以属于非递减序列。 本题注意点：本题开始比较a[i+1]与a[i]进行比较，为了避免越界，数组定义为n+1个，同时给a[n] &#x3D; 0; a[n] &#x3D; 0带来的影响，我们分为三种情况讨论： 若到a[n-1] 的最后一组是非递减序列，当i&#x3D;&#x3D;n-1，a[i] &gt;a[i+1]，因为前面的数都是大于0的，这个输入条件已经说明了(去看看题目输入条件描述)，里面的循环结束，i++，count++，i&#x3D;&#x3D;n，外面的循环结束。 若到a[n-1] 的最后一组是非递增序列，当i&#x3D;&#x3D;n-1，a[i] &gt;a[i+1]，因为前面的数都是大于0的，这个输入条件已经说明了(去看看题目输入条件描述)，循环再走一次，i++， i&#x3D;&#x3D; n，里面的循环结束，i++，count++，i&#x3D;&#x3D;n+1，外面的循环结束。 第三种情况 1 2 1 2 1最后一个数是单独的情况，后面补个0，序列变成1 2 1 2 1 0，当走完全面的序列i&#x3D;&#x3D;n-1时，a[i] &gt; a[i+1],进入判断出一个非递增序列，count++，i++,循环结束。 也就是说数组最后一个位置多增加一个0，不会影响第1、2情况的判断，主要是帮助第3情况的正确判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// 本题牛客测试用例不全，至少应该增加以下两组测试用例// 输入：// 4 // 1 3 2 3// 输出：2// 输入：// 6 // 3 2 1 1 2 3// 输出：2int main()&#123; int n; cin &gt;&gt; n; // 注意这里多给了一个值，是处理越界的情况的比较，具体参考上面的解题思路 vector&lt;int&gt; a; a.resize(n + 1);//这里有个坑，这个题越界了牛客测不出来，给n,并且不写a[n] = 0;不会报错，但是最好写上 a[n] = 0; //读入数组 int i = 0; for (i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; i = 0; int count = 0; while (i &lt; n) &#123; // 非递减子序列 if (a[i] &lt; a[i + 1]) &#123; while (i &lt; n &amp;&amp; a[i] &lt;= a[i + 1]) i++; count++; i++; &#125; else if (a[i] == a[i + 1]) &#123; i++; &#125; else // 非递增子序列 &#123; while (i &lt; n &amp;&amp; a[i] &gt;= a[i + 1]) i++; count++; i++; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 69389-倒置字符串https://www.nowcoder.com/practice/ee5de2e7c45a46a090c1ced2fdc62355?tpId=85&amp;&amp;tqId=29867&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 【题目解析】：本题题意很简单，就是将一段字符串中的前后单词交换，以单词为单位逆置。 【解题思路1】：先将整个字符串逆置过来，再遍历字符串，找出每个单词，对单词逆置。这里我们使用了stl算法中的reverse，所以这里使用迭代器遍历string 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt; using namespace std;int main()&#123; string s; // 注意这里要使用getline，cin&gt;&gt;s遇到空格就接收结束了 getline(cin, s); // 翻转整个句子 reverse(s.begin(), s.end()); // 翻转单词 auto start = s.begin(); while (start != s.end()) &#123; auto end = start; while (end != s.end() &amp;&amp; *end != &#x27; &#x27;) end++; reverse(start, end); if (end != s.end()) start = end + 1; else start = end; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 【解题思路2】：第二思路是一个比较讨巧的思路，直接利用cin&gt;&gt;s接收输入，遇到空格就结束了，自然就分割开了每个单词，其次将每次接收到的单词拼接到之前串的前面就逆置过来了 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// cin读取string时自动会被空格分隔开，用另一个字符串存储进行逆序输出int main()&#123; string s1, s2; cin &gt;&gt; s2; while (cin &gt;&gt; s1) s2 = s1 + &quot; &quot; + s2; cout &lt;&lt; s2 &lt;&lt; endl; return 0;&#125;"}],"posts":[{"title":"开始第一章","slug":"开始第一章","date":"2022-10-01T22:44:56.000Z","updated":"2022-10-01T22:45:09.935Z","comments":true,"path":"2022/10/02/开始第一章/","link":"","permalink":"http://example.com/2022/10/02/%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"C++方向编程题答案","date":"2022-10-01T22:26:51.808Z","updated":"2022-10-02T00:48:09.353Z","comments":true,"path":"2022/10/02/C++方向编程题答案/","link":"","permalink":"http://example.com/2022/10/02/C++%E6%96%B9%E5%90%91%E7%BC%96%E7%A8%8B%E9%A2%98%E7%AD%94%E6%A1%88/","excerpt":"","text":"C++方向编程题答案第一周day1 100449-组队竞赛链接：https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b?orderByHotValue=1&amp;page=1&amp;onlyReference=false 【题目解析】：队伍的水平值等于该队伍队员中第二高水平值，为了所有队伍的水平值总和最大的解法，也就是说每个队伍的第二个值是尽可能大的值。所以实际值把最大值放到最右边，最小是放到最左边。 【解题思路】： 本题的主要思路是贪心算法，贪心算法其实很简单，就是每次选值时都选当前能看到的局部最解忧，所以这里的贪心就是保证每组的第二个值取到能选择的最大值就可以，我们每次尽量取最大，但是最大的数不可能是中位数，所以退而求其次，取 每组中第二大的 例如 现在排序后 有 1 2 5 5 8 9 ，那么分组为1 8 9 和 2 5 5 关系arr[arr.length-2*(i+1)] 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; // IO型OJ可能会有多组测试用例，所以这里要持续接收输入多组测试用例。 int n; while (cin &gt;&gt; n) &#123; long long sum = 0; vector&lt;int&gt; a; a.resize(3*n); for (int i = 0; i &lt; (3 * n); i++) &#123; cin &gt;&gt; a[i]; &#125; std::sort(a.begin(), a.end()); for (int i = 0; i &lt; n; i++) &#123; sum+=a[a.size()-(2*(i+1))]; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;&#125; 69390-删除公共字符链接：https://www.nowcoder.com/practice/f0db4c36573d459cae44ac90b90c6212?tpId=85&amp;&amp;tqId=29868&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 【题目解析】：本题描述很简单，题目描述很清楚，读题即可 【解题思路】：本题如果使用传统的暴力查找方式，如判断第一个串的字符是否在第二个串中，在再挪动字符删除这个字符的方式，效率为O(N^2)，效率太低，很难让人满意。 将第二个字符串的字符都映射到一个hashtable数组中，用来判断一个字符在这个字符串。 判断一个字符在第二个字符串，不要使用删除，这样效率太低，因为每次删除都伴随数据挪动。这里可以考虑使用将不在字符添加到一个新字符串，最后返回新新字符串。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; // 注意这里不能使用cin接收，因为cin遇到空格就结束了。 // oj中IO输入字符串最好使用getline。 string str1,str2; //cin&gt;&gt;str1; //cin&gt;&gt;str2; getline(cin, str1); getline(cin, str2); // 使用哈希映射思想先str2统计字符出现的次数 int hashtable[256] = &#123;0&#125;; for(size_t i = 0; i &lt; str2.size(); ++i) &#123; hashtable[str2[i]]++; &#125; // 遍历str1，str1[i]映射hashtable对应位置为0，则表示这个字符在 // str2中没有出现过，则将他+=到ret。注意这里最好不要str1.erases(i) // 因为边遍历，边erase，容易出错。 string ret; for(size_t i = 0; i &lt; str1.size(); ++i) &#123; if(hashtable[str1[i]] == 0) ret += str1[i]; &#125; cout&lt;&lt;ret&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-10-01T14:42:02.324Z","updated":"2022-10-01T22:45:09.933Z","comments":true,"path":"2022/10/01/hello-world/","link":"","permalink":"http://example.com/2022/10/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}